# vim: tabstop=4 shiftwidth=4 softtabstop=4
# Copyright 2012 NEC Corporation.
# All Rights Reserved.
#

import logging
from webob import exc as h_exc

from quantum.api.api_common import OperationalStatus
from quantum.common import exceptions as q_exc
from quantum.db import api as db
from quantum.plugins.nec.db import nec_db as ndb
from quantum.plugins.nec.db import quantum_db_extension as dbe
from quantum.plugins.nec.nec_plugin_config import NECConfig
from quantum.plugins.nec.tools import client
from quantum.quantum_plugin_base import QuantumPluginBase

LOG = logging.getLogger(__name__)


class NECPluginException(h_exc.HTTPInternalServerError):
    pass


class NECPlugin(QuantumPluginBase):
    """The Quantum NEC Plug-in controls an OpenFlow Controller.

    The Quantum NEC Plug-in maps L2 logical networks to L2 virtualized networks
    on an OpenFlow enabled network.  An OpenFlow Controller (OFC) provides
    L2 network isolation without VLAN and this plugin controls the OFC.

    :param tenant_id:       Logical Tenant ID on Quantum
    :param network_id:      Logical Network ID on Quantum
    :param port_id:         Logical Port ID on Quantum
    :param ofn_tenant_id:   Virtual Tenant ID on OFC
    :param ofn_network_id:  Virtual Network ID on OFC
    :param ofn_port_id:     Virtual Port ID on OFC
    :param vifinfo:         Virtual Interface Information in the domain of OFC

    The IDs like ofn_* could be generated by NEC Plug-in or OFC.
    """

    def __init__(self, config_file=None):
        self.conf = NECConfig(config_file)
        self.driver = self.conf.OFC_DRIVER(self.conf.OFC_HOST,
                                           self.conf.OFC_PORT)
        ndb.initialize(self.conf)
        self.supported_extension_aliases = ["VIFINFOS"]
        if self.conf.FILTER:
            self.supported_extension_aliases.append("FILTERS")

    def _create_ofn_tenant(self, tenant_id):
        ofn_tenant_id = self.driver.create_tenant(tenant_id)
        ofn_tenant = ndb.add_ofn_tenant(ofn_tenant_id, tenant_id)
        LOG.debug("create new ofn_tenant %s for tenant %s." %
                  (ofn_tenant.ofn_tenant_id, ofn_tenant.tenant_id))
        return ofn_tenant

    def _delete_orphan_ofn_tenant(self, tenant_id):
        num_of_networks = len(db.network_list(tenant_id))
        if num_of_networks == 0:
            ofn_tenant = ndb.get_ofn_tenant(tenant_id)
            if ofn_tenant:
                self.driver.delete_tenant(ofn_tenant.ofn_tenant_id)
                ndb.del_ofn_tenant(tenant_id)

    def _get_ofn_tenant_id(self, tenant_id):
        ofn_tenant = ndb.get_ofn_tenant(tenant_id)
        if not ofn_tenant:
            LOG.warning("_get_ofn_tenant_id(): ofn_tenant not found "
                        "(tenant_id = %s)" % tenant_id)
            raise NECPluginException("NotFound ofn_tenant_id for "
                                 "tenant_id %s." % tenant_id)
        return ofn_tenant.ofn_tenant_id

    def _get_ofn_network_id(self, network_id):
        ofn_network = ndb.get_ofn_network(network_id)
        if not ofn_network:
            LOG.error("_get_ofn_network_id(): ofn_network not found "
                      "(network_id = %s)" % network_id)
            raise NECPluginException("NotFound ofn_network_id for "
                                 "network_id %s." % network_id)
        return ofn_network.ofn_network_id

    def _get_ofn_port_id(self, port_id):
        ofn_port = ndb.get_ofn_port(port_id)
        if not ofn_port:
            LOG.error("_get_ofn_port_id(): ofn_port not found "
                      "(port_id = %s)" % port_id)
            raise NECPluginException("NotFound ofn_port_id for "
                                 "port_id %s." % port_id)
        return ofn_port.ofn_port_id

    def _get_ofn_filter_id(self, filter_id):
        ofn_filter = ndb.get_ofn_filter(filter_id)
        if not ofn_filter:
            LOG.error("_get_ofn_filter_id(): ofn_filter not found "
                      "(filter_id = %s)" % filter_id)
            raise NECPluginException("NotFound ofn_filter_id for "
                                 "filter_id %s." % filter_id)
        return ofn_filter.ofn_filter_id

    def _port_attachable(self, port):
        if not port:
            LOG.debug("_port_attachable(): no port.")
            return False
        if not port.interface_id:
            LOG.debug("_port_attachable(): no port.interface_id.")
            return False
        if not port.state.upper() in "ACTIVE":
            LOG.debug("_port_attachable(): port.state is not ACTIVE.")
            return False
        if not ndb.get_vifinfo(port.interface_id):
            LOG.debug("_port_attachable(): no vifinfo for the port.")
            return False
        return True

    def _attach(self, tenant_id, network_id, port_id, interface_id):
        LOG.debug("_attach(): called")
        ofn_tenant_id = self._get_ofn_tenant_id(tenant_id)
        ofn_network_id = self._get_ofn_network_id(network_id)
        vifinfo = ndb.get_vifinfo(interface_id)

        if self.conf.FILTER:
            port = db.port_get(port_id, network_id)
            for filter in ndb.get_associated_filters(network_id, port_id):
                self._enable_filter(tenant_id, network_id, filter, port)

        ofn_port_id = self.driver.create_port(ofn_tenant_id,
                                              ofn_network_id,
                                              port_id,
                                              vifinfo)

        LOG.debug("_attach(): ofn_port_id = %s" % ofn_port_id)
        ndb.add_ofn_port(ofn_port_id, port_id)
        db.port_update(port_id, network_id, op_status=OperationalStatus.UP)

    def _detach(self, tenant_id, network_id, port_id):
        LOG.debug("_detach(): called")
        ofn_tenant_id = self._get_ofn_tenant_id(tenant_id)
        ofn_network_id = self._get_ofn_network_id(network_id)
        ofn_port_id = self._get_ofn_port_id(port_id)
        self.driver.delete_port(ofn_tenant_id, ofn_network_id, ofn_port_id)
        ndb.del_ofn_port(port_id)
        db.port_update(port_id, network_id, op_status=OperationalStatus.DOWN)

        if self.conf.FILTER:
            port = db.port_get(port_id, network_id)
            for filter in ndb.get_associated_filters(network_id, port_id):
                self._disable_filter(tenant_id, network_id, filter.uuid)

    def get_all_networks(self, tenant_id, **kwargs):
        """
        Returns a dictionary containing all
        <network_uuid, network_name> for
        the specified tenant.
        """
        LOG.debug("get_all_networks() called")
        filter_opts = kwargs.get('filter_opts', None)
        nets = []
        for net in db.network_list(tenant_id):
            net_item = {'net-id': net.uuid,
                        'net-name': net.name,
                        'net-op-status': net.op_status}
            nets.append(net_item)
        return nets

    def get_network_details(self, tenant_id, network_id):
        """
        retrieved a list of all the remote vifs that
        are attached to the network
        """
        LOG.debug("get_network_details() called")
        db.validate_network_ownership(tenant_id, network_id)
        net = db.network_get(network_id)
        # Retrieves ports for network
        ports = self.get_all_ports(tenant_id, network_id)
        return {'net-id': net.uuid,
                'net-name': net.name,
                'net-op-status': net.op_status,
                'net-ports': ports}

    def create_network(self, tenant_id, net_name, **kwargs):
        """
        Creates a new Virtual Network, and assigns it
        a symbolic name.
        """
        LOG.debug("create_network() called")
        new_net = db.network_create(tenant_id, net_name)

        ofn_tenant = ndb.get_ofn_tenant(tenant_id)
        if ofn_tenant is None:
            ofn_tenant = self._create_ofn_tenant(tenant_id)
        ofn_tenant_id = ofn_tenant.ofn_tenant_id

        try:
            ofn_network_id = self.driver.create_network(ofn_tenant_id,
                                                        new_net.uuid,
                                                        net_name)
            ndb.add_ofn_network(ofn_network_id, new_net.uuid)
        except client.ClientException as e:
            LOG.error("create_network() failed on OFC")
            db.network_destroy(new_net.uuid)
            raise e

        db.network_update(new_net.uuid, net_name,
                          op_status=OperationalStatus.UP)
        return {'net-id': new_net.uuid}

    def delete_network(self, tenant_id, network_id):
        """
        Deletes the network with the specified network identifier
        belonging to the specified tenant.
        """
        LOG.debug("delete_network() called")
        db.validate_network_ownership(tenant_id, network_id)
        net = db.network_get(network_id)
        # Verify that no attachments are plugged into the network
        if net:
            for port in db.port_list(network_id):
                if port['interface_id']:
                    raise q_exc.NetworkInUse(net_id=network_id)

            ofn_tenant_id = self._get_ofn_tenant_id(tenant_id)
            ofn_network_id = self._get_ofn_network_id(network_id)
            self.driver.delete_network(ofn_tenant_id, ofn_network_id)

            db.network_destroy(network_id)
            self._delete_orphan_ofn_tenant(tenant_id)
            return net
        # Network not found
        raise q_exc.NetworkNotFound(net_id=network_id)

    def update_network(self, tenant_id, network_id, **kwargs):
        """
        Updates the attributes of a particular Virtual Network.
        """
        LOG.debug("update_network() called")
        db.validate_network_ownership(tenant_id, network_id)

        net = db.network_get(network_id)
        new_name = kwargs.get('name', net.name)
        if net.name != new_name:
            ofn_tenant_id = self._get_ofn_tenant_id(tenant_id)
            ofn_network_id = self._get_ofn_network_id(network_id)
            self.driver.rename_network(ofn_tenant_id, ofn_network_id, new_name)
            net = db.network_update(network_id, tenant_id, **kwargs)

        return net

    def get_all_ports(self, tenant_id, network_id, **kwargs):
        """
        Retrieves all port identifiers belonging to the
        specified Virtual Network.
        """
        LOG.debug("get_all_ports() called")
        db.validate_network_ownership(tenant_id, network_id)
        port_ids = []
        ports = db.port_list(network_id)
        for x in ports:
            d = {'port-id': x.uuid}
            port_ids.append(d)
        return port_ids

    def get_port_details(self, tenant_id, network_id, port_id):
        """
        This method allows the user to retrieve a remote interface
        that is attached to this particular port.
        """
        LOG.debug("get_port_details() called")
        db.validate_port_ownership(tenant_id, network_id, port_id)
        port = db.port_get(port_id, network_id)
        return {'port-id': port.uuid,
                'attachment': port.interface_id,
                'port-state': port.state,
                'port-op-status': port.op_status}

    def create_port(self, tenant_id, network_id, port_state=None, **kwargs):
        """
        Creates a port on the specified Virtual Network.
        """
        LOG.debug("create_port() called")
        db.validate_network_ownership(tenant_id, network_id)
        port = db.port_create(network_id, port_state)
        # Put operational status DOWN
        db.port_update(port.uuid, network_id,
                       op_status=OperationalStatus.DOWN)
        return {'port-id': port.uuid}

    def update_port(self, tenant_id, network_id, port_id, **kwargs):
        """
        Updates the attributes of a port on the specified Virtual Network.
        """
        LOG.debug("update_port() called")

        db.validate_port_ownership(tenant_id, network_id, port_id)
        port = db.port_get(port_id, network_id)
        old_state = port.state
        new_state = kwargs.get('state', old_state)
        if new_state not in ('ACTIVE', 'DOWN'):
            raise q_exc.StateInvalid(port_state=new_state)

        if old_state in 'ACTIVE' and new_state in 'DOWN':
            if self._port_attachable(port):
                self._detach(tenant_id, network_id, port_id)

        port = db.port_update(port_id, network_id, **kwargs)

        if old_state in 'DOWN' and new_state in 'ACTIVE':
            if self._port_attachable(port):
                self._attach(tenant_id, network_id, port_id, port.interface_id)

        return {'port-id': port_id, 'port-state': new_state}

    def delete_port(self, tenant_id, network_id, port_id):
        """
        Deletes a port on a specified Virtual Network,
        if the port contains a remote interface attachment,
        the remote interface is first un-plugged and then the port
        is deleted.
        """
        LOG.debug("delete_port() called")
        db.validate_port_ownership(tenant_id, network_id, port_id)
        port = db.port_get(port_id, network_id)
        if port['interface_id']:
            raise q_exc.PortInUse(net_id=network_id, port_id=port_id,
                                  att_id=port['interface_id'])
        try:
            port = db.port_destroy(port_id, network_id)
        except Exception, e:
            LOG.error("Failed to delete port: %s" % str(e))
            raise NECPluginException("Failed to delete port.")
        return {'port-id': port.uuid}

    def plug_interface(self, tenant_id, network_id, port_id, interface_id):
        """
        Attaches a remote interface to the specified port on the
        specified Virtual Network.
        """
        LOG.debug("plug_interface() called")
        db.validate_port_ownership(tenant_id, network_id, port_id)

        # Validate attachment
        port = db.port_get(port_id, network_id)
        if port.interface_id:
            raise q_exc.PortInUse(net_id=port.network_id,
                                  port_id=port.uuid,
                                  att_id=port.interface_id)
        p = dbe.get_plugged_port(interface_id)
        if p:
            net = db.network_get(p.network_id)
            if net.tenant_id == tenant_id:
                p_id = p.uuid
            else:
                p_id = "Not Available"
            raise q_exc.AlreadyAttached(net_id=network_id,
                                        port_id=port_id,
                                        att_id=interface_id,
                                        att_port_id=p_id)

        port = db.port_set_attachment(port_id, network_id, interface_id)
        if self._port_attachable(port):
            self._attach(tenant_id, network_id, port_id, interface_id)

    def unplug_interface(self, tenant_id, network_id, port_id):
        """
        Detaches a remote interface from the specified port on the
        specified Virtual Network.
        """
        LOG.debug("unplug_interface() called")
        db.validate_port_ownership(tenant_id, network_id, port_id)
        port = db.port_get(port_id, network_id)
        if self._port_attachable(port):
            self._detach(tenant_id, network_id, port_id)
        db.port_unset_attachment(port_id, network_id)

    # for Quantum Extension APIs

    def get_vifinfo(self, interface_id):
        LOG.debug("get_vifinfo() called")
        vifinfo = ndb.get_vifinfo(interface_id)
        if not vifinfo:
            return None
        ofs_port = {}
        if vifinfo.datapath_id:
            ofs_port['datapath_id'] = vifinfo.datapath_id
        if vifinfo.port_no:
            ofs_port['port_no'] = str(vifinfo.port_no)
        if vifinfo.vlan_id != 65535:
            ofs_port['vlan_id'] = str(vifinfo.vlan_id)
        if vifinfo.mac:
            ofs_port['mac'] = vifinfo.mac
        v_dict = {'vifinfo': {
                    'interface_id': vifinfo.interface_id,
                    'ofs_port': ofs_port}}
        return v_dict

    def list_vifinfos(self):
        LOG.debug("list_vifinfos() called")
        vifs = ndb.list_vifinfos()
        id_list = [{'interface_id': vif.interface_id} for vif in vifs]
        return {'vifinfos': id_list}

    def add_vifinfo(self, interface_id, datapath_id=None, port_no=None,
                    vlan_id=65535, mac=None):
        LOG.debug("add_vifinfo() called")
        ndb.add_vifinfo(interface_id, datapath_id, port_no, vlan_id, mac)
        port = dbe.get_plugged_port(interface_id)
        if self._port_attachable(port):
            network = db.network_get(port.network_id)
            self._attach(network.tenant_id, network.uuid, port.uuid,
                         interface_id)

    def update_vifinfo(self, interface_id, datapath_id=None, port_no=None,
                    vlan_id=65535, mac=None):
        LOG.debug("update_vifinfo() called")
        vifinfo = self.get_vifinfo(interface_id)
        if vifinfo:
            ofs_port = vifinfo['vifinfo']['ofs_port']
            changed = False
            for key in ['datapath_id', 'port_no', 'vlan_id', 'mac']:
                if ofs_port.get(key, None) != eval(key):
                    LOG.debug("update_vifinfo(): %s changed." % key)
                    changed = True
            if changed:
                self.delete_vifinfo(interface_id)
                self.add_vifinfo(interface_id, datapath_id, port_no, vlan_id,
                                 mac)
            else:
                LOG.debug("update_vifinfo(): nothing changed.")
        else:
            self.add_vifinfo(interface_id, datapath_id, port_no, vlan_id, mac)

    def delete_vifinfo(self, interface_id):
        LOG.debug("delete_vifinfo() called")
        port = dbe.get_plugged_port(interface_id)
        if self._port_attachable(port):
            network = db.network_get(port.network_id)
            self._detach(network.tenant_id, network.uuid, port.uuid)
        ndb.del_vifinfo(interface_id)

    def _enable_filter(self, tenant_id, network_id, filter, port=None):
        LOG.debug("_enable_filter() called.")
        ofn_tenant_id = self._get_ofn_tenant_id(tenant_id)
        ofn_network_id = self._get_ofn_network_id(network_id)
        if port:
            vifinfo = ndb.get_vifinfo(port.interface_id)
            if not vifinfo:
                LOG.error("_enable_filter(): failed to get vifinfo of "
                          "port.uuid=%s port.interface_id=%s" %
                          (port.uuid, port.interface_id))
                raise NECPluginException("NotFound vifinfo of "
                                         "port %s." % port.uuid)
        else:
            vifinfo = None

        ofn_filter_id = self.driver.create_filter(ofn_tenant_id,
                                                  ofn_network_id,
                                                  filter, vifinfo)
        ndb.add_ofn_filter(ofn_filter_id, filter.uuid)

    def _disable_filter(self, tenant_id, network_id, filter_id):
        LOG.debug("_disable_filter() called.")
        ofn_tenant_id = self._get_ofn_tenant_id(tenant_id)
        ofn_network_id = self._get_ofn_network_id(network_id)
        ofn_filter_id = self._get_ofn_filter_id(filter_id)
        res = self.driver.delete_filter(ofn_tenant_id, ofn_network_id,
                                        ofn_filter_id)
        ndb.del_ofn_filter(filter_id)

    def _validate_port_in_filter_dict(self, tenant_id, network_id,
                                      filter_dict):
        condition = filter_dict.get('condition', None)
        if condition:
            port_id = filter_dict['condition'].get('in_port', None)
            if port_id:
                db.validate_port_ownership(tenant_id, network_id, port_id)

    def get_filter(self, tenant_id, network_id, filter_id):
        LOG.debug("get_filter() called.")
        db.validate_network_ownership(tenant_id, network_id)
        filter = ndb.get_filter(filter_id, network_id)
        return filter.dic()

    def list_filters(self, tenant_id, network_id):
        LOG.debug("list_filters() called.")
        db.validate_network_ownership(tenant_id, network_id)
        filters = ndb.list_filters(network_id)
        id_list = [{'id': filter.uuid} for filter in filters]
        return {'filters': id_list}

    def add_filter(self, tenant_id, network_id, filter_dict):
        LOG.debug("add_filter() called")
        db.validate_network_ownership(tenant_id, network_id)
        self._validate_port_in_filter_dict(tenant_id, network_id, filter_dict)
        filter = ndb.add_filter(network_id, filter_dict)
        if filter.in_port:
            port = db.port_get(filter.in_port, network_id)
            if self._port_attachable(port):
                self._enable_filter(tenant_id, network_id, filter, port)
        else:
            self._enable_filter(tenant_id, network_id, filter)
        return {'filter': {'id': filter.uuid}}

    def update_filter(self, tenant_id, network_id, filter_id, filter_dict):
        LOG.debug("update_filter() called")
        db.validate_network_ownership(tenant_id, network_id)
        self._validate_port_in_filter_dict(tenant_id, network_id, filter_dict)
        filter = ndb.get_filter(filter_id, network_id)
        if filter.in_port:
            port = db.port_get(filter.in_port, network_id)
            if self._port_attachable(port):
                self._disable_filter(tenant_id, network_id, filter_id)
        else:
            self._disable_filter(tenant_id, network_id, filter_id)
        filter = ndb.update_filter(filter_id, network_id, filter_dict)
        if filter.in_port:
            port = db.port_get(filter.in_port, network_id)
            if self._port_attachable(port):
                self._enable_filter(tenant_id, network_id, filter, port)
        else:
            self._enable_filter(tenant_id, network_id, filter)

    def delete_filter(self, tenant_id, network_id, filter_id):
        LOG.debug("delete_filter() called")
        db.validate_network_ownership(tenant_id, network_id)
        filter = ndb.get_filter(filter_id, network_id)
        if filter.in_port:
            db.validate_port_ownership(tenant_id, network_id, filter.in_port)
            port = db.port_get(filter.in_port, network_id)
            if self._port_attachable(port):
                self._disable_filter(tenant_id, network_id, filter_id)
        else:
            self._disable_filter(tenant_id, network_id, filter_id)
        ndb.del_filter(filter_id, network_id)
